# R

## markdownでの数式の扱い

[MathJax](http://www.mathjax.org/)をつかうのがよいようだ。MathJaxはWebAPIなので、繋げる方法が別途必要。

とおもったら、R studioではR markdownがつかえるので、日本語入力に難があることをのぞけば（あかんがな）かなり良い感じに表示できる。ただ、R markdownではエスケープである¥が1個で良い。これは他では2つ必要だったりするので、ちょっと整合性が面倒かも。

### 例

バックスラッシュは**OPTION+¥**で入力。

- ギリシャ文字は[ここ](http://www.h7.dion.ne.jp/~sappon/info/texsymbl.html)参照。
    \\(x\\), \\(y\\)
- 平均を表すバー
    \bar{x}
- x1からxiまで
    \\[
    x_1 + x_2 + \cdots + x_n
    \\]
- Σ
    \\[
    v = \sum_{i=1}^n (x_i - \bar{x})
    \\]

数学記号は[ここ](http://hooktail.sub.jp/tex/symbol/mathsymbols.html)参照。

- 複数行
    \\[
    v = \sum_{i=1}^n (x_i - \bar{x}) \\\
    x_1 + x_2 + x_3 + \cdots + x_n
    \\]

## 統計の基礎

### 平均と偏差

平均(mean, average) = 総和を個数で割ったもの = ~x = 1/n * (x1+x2+x3+....+xn)
データがどのあたりを中心にしているかを表す指標の一つ。他にはメジアン（中央値）がある。

\\[\bar{x} = \mu = \sum_{i=1}^n x_i \\]

偏差(deviation) = 平均からどれだけ離れているか = dx = xi - ~x

\\[\delta x = x_i - \bar{x} \\]

偏差の総和は0になる。
\\[ \begin{aligned} \\\
\delta x_1 + \delta x_2 + \cdots + \delta x_n = (x_1 - \bar{x}) + (x_2 - \bar{x}) + \cdots + (x_n - \bar{x}) \\\
    = (x_1 + x_2 + \cdots + x_n) - n \bar{x} \\\
    = n \times \frac{1}{n} (x_1 + x_2 + \cdots + x_n) + n \bar{x} \\\
    = 0
\end{aligned} \\]

データがどの程度バラバラかをあらわすのに、偏差の平均を使おうとした場合偏差の総和が0なため平均も0になり役に立たない。
そこで偏差の二乗 $$\sigma^2$$ の平均をつかって定義し、データのひろがりを表す尺度とする。これを分散(variance)とよぶ。

\\[ \begin{aligned} \\\
\sigma^2 = \frac{1}{n} { (x_1 - \bar{x})^2 + (x_2 - \bar{x})^2 + \cdots + (x_n - \bar{x})^2 } \\\
    = \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x})^2
\end{aligned} \\]

また分散の平方根 $$\sqrt{ \sigma^2 }$$を標準偏差(standard variance)と呼ぶ。
分散は尺度として計算で求めることができるが、元の数値の単位がメートルだとすると分散の単位は平方メートルに変わってしまう。そこで単位が同じ標準偏差を求めることでデータとの比較が用意になる。データのばらつきの大きさを表すという意味で標準誤差(standard error)と呼ばれる場合もある。

平均と標準偏差のワンセットで、データの分布と広がりを表すことが可能になる。

上の分散を求める式を展開すると以下のようになる。

\\[
\sigma^2 = \bar{x^2} - \bar{x}^2
\\]

つまり、分散 = 二条の平均 - 平均の二乗 となる。

## Rで平均と分散を調査

データをコピー。

```{r}
    > x <- c(43.6, 45.2, 45.4, 45.8, 47.2, 47.8, 48.2, 48.7, 48.8, 48.9, 49.0, 49.0, 49.4, 49.5, 49.8, 50.4, 50.5, 50.9, 50.9, 51.2, 51.2, 51.2, 51.3, 51.3, 51.6, 51.7, 51.7, 51.8, 52.0, 52.0, 52.1, 52.1, 52.1, 52.2, 52.3, 52.7, 52.7, 52.8, 52.9, 52.9, 53.1, 53.1, 53.8, 54.0, 54.5, 54.5, 54.6, 54.7, 54.7, 54.7, 54.8, 54.9, 55.1, 55.1, 55.2, 55.3, 55.4, 55.4, 55.4, 55.6, 55.7, 55.8, 55.9, 56.1, 56.3, 56.3, 56.3, 56.4, 56.5, 56.7, 56.8, 57.0, 57.1, 57.1, 57.2, 57.3, 57.6, 57.7, 57.8, 58.1, 58.4, 58.6, 58.7, 58.7, 58.7, 58.7, 59.1, 59.3, 59.9, 60.0, 60.1, 60.3, 60.5, 60.6, 60.6, 60.7, 61.3, 62.7, 64.2, 64.6)
```

xにバインドされたデータを表示

```{r}
    > x
      [1] 43.6 45.2 45.4 45.8 47.2 47.8 48.2 48.7 48.8 48.9 49.0 49.0 49.4 49.5 49.8 50.4 50.5 50.9 50.9 51.2
     [21] 51.2 51.2 51.3 51.3 51.6 51.7 51.7 51.8 52.0 52.0 52.1 52.1 52.1 52.2 52.3 52.7 52.7 52.8 52.9 52.9
     [41] 53.1 53.1 53.8 54.0 54.5 54.5 54.6 54.7 54.7 54.7 54.8 54.9 55.1 55.1 55.2 55.3 55.4 55.4 55.4 55.6
     [61] 55.7 55.8 55.9 56.1 56.3 56.3 56.3 56.4 56.5 56.7 56.8 57.0 57.1 57.1 57.2 57.3 57.6 57.7 57.8 58.1
     [81] 58.4 58.6 58.7 58.7 58.7 58.7 59.1 59.3 59.9 60.0 60.1 60.3 60.5 60.6 60.6 60.7 61.3 62.7 64.2 64.6
```

平均と平方根と歪度と突度

```{r}
    > mean(x)                                        # 平均
    [1] 54.461
    > plot(x)
    > sum((x-mean(x))^2)                             # 平方和
    [1] 1784.138
    > mean((x-mean(x))^3)/(sd(x)^3)                  # 歪度
    [1] -0.09854636
    > mean((x-mean(x))^4)/(sd(x)^4)                  # 尖度
    [1] 2.714933
```

データのサマリーを表示

```{r}
    > summary(x)
       Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
      43.60   51.68   54.75   54.46   57.23   64.60
```

ヒストグラムを表示

```{r}
    > barplot(x)
```

分散を計算。用意されているvar()は不偏分散であることに注意。上で上げたものは標本標準偏差である。
ここではサンプルから母集団を推測するわけではなく、母集団＝標本集団なので標本標準偏差を用いる。サンプリングした結果から母集団を推測する場合には不変標準偏差を使用する。この場合の自由度dfはn-1となる。

```{r}
    > var(x)                                         # 不偏分散
    [1] 18.02159
    > variance <- function(x) var(x)*(length(x)-1)/length(x)   # 標本分散を求める関数を定義
    > variance(x)
    [1] 17.84138
    > sd(x)                                          # 不偏標準偏差
    [1] 4.245185
    > sqrt(variance(x))                              # 標本標準偏差
    [1] 4.223906
```

不偏分散と標本分散では自由度が1違う。標本分散の標本数をnとした場合に、不偏分散の自由度はn-1となる

参考: [不偏分散と標本分散の違い](http://staff.aist.go.jp/t.ihara/dispersion.html)。

### チェブシェフの不等式(Chebyshev's inequality)

    あるデータの集合の平均 μ と 標準偏差 σ が分かっているとする。
    その時,全体のうち μ ± aσ の範囲からはみ出すデータの割合は,任意の a について$$\frac{1}{a^2} $$以下しかない.

上のデータでa=1とすると、AVG=54.46でSD=4.22なので、a=2で54.46を中心とした範囲[46.02-62.9]に3/4のデータが存在することになる。
うえのデータはn=100なので、外れたデータは25個以下しかない。実際には6個なので合致している。
この不等式によりデータは平均から当座かるほど割合が減少し、その減り方は標準偏差で図ることができることがわかる。

## 四分位数

データを同数に４頭分した時に、全体の1/4, 1/2, 3/4の位置に相当する値を、それぞれ第１四分位数(first quartile)、中央値(median, second quartile)、第３四分位数(third quartile)、という。

上の例題をもとにQ1, M, Q3を求める。

Q1 = 1/4 (x25+ 3*x26) = 1/4(51.6+3*51.7) = 51.675
M  = 1/2 (x50,51)     = 1/2(54.7+54.8)   = 54.75
Q3 = 1/4 (3*x75 + x76)= 1/4(3*57.2+57.3) = 57.225

### R

Rではsummary関数でひと通り計算される。計算の桁数はdigitsオプションで変更する。

```{r}
    > summary(x)
       Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
      43.60   51.68   54.75   54.46   57.23   64.60
    > summary(x, digits=3)
       Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
       43.6    51.7    54.8    54.5    57.2    64.6
    > summary(x, digits=4)
       Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
      43.60   51.68   54.75   54.46   57.23   64.60
    > summary(x, digits=5)
       Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
     43.600  51.675  54.750  54.461  57.225  64.600
```

## ５数要約

最小値、第１四分位数、中央値、第３四分位数、最大値の５つをまとめて５数要約(five number summary)という。
これらをグラフィカルに表示したものを箱ひげ図(boxplot)という。

第３四分位数から第１四分位数を引いた値を四分位範囲(IQR, Interquartile Range)といい、その半分の値を四分位偏差という。データの半分が含まれる幅を意味する。

外れ値(outlier)は集団から遠く離れたデータのことである。数学的な定義はないが四分位数と関連付けた定義がわかりやすい。

    データ $$x$$ は、次の条件のいずれかを満たすときに外れ値という。

    $$ x < Q1 - k(Q3-Q1)$$ または、$$ x > Q3 + k(Q3-Q1)$$

Q3-Q1 = IQRなので、データがQ1,Q3の外側にIQRのk倍離れている場合に外れ値となる。1.5 <= k <= 3ととる。

平均や標準偏差は外れ値によって大きく影響を受けるが、中央値や四分位数はあまり影響を受けないため「頑健(robust)」であると表現される。



# R

R での箱ひげ図は簡単

    > boxplot(x)

参考：(http://r.livedocs.net/graph/boxplot.html)

外れ値は数多くの検出方法がある。[参考1](https://sites.google.com/site/scriptofbioinformatics/mian-qiangmemo/waire-zhi-jian-chu-zhi-shi), [参考2](http://www.slideshare.net/sfchaos/ss-16709258)

## 度数分布から統計量を求める

度数分布表は生データの縮約であり、ここから統計量を類推することができる。

平均 = $$\bar{x} = \frac{1}{n}\sum_{i=1}^k x_i f_i = \sum_{i=1}^k (x_i \times \frac{n}{f_i})$$
     = (i番目の階級値 x i番目の階級の割合)の和

分散 = $$\sigma^2 = \frac{\sum_{i=1}^k(x_i - \bar{f_i}}{n} = \sum_{i=1}^k(x_i - \bar{x})^2$$
     = (i番目の階級の偏差の2乗 x i番目の階級の割合)の和
    \\[
     = \sigma^2 = \frac{\sum_{i=1}^k f_i x_i^2}{n} - \bar{x}^2
    \\]

## R tips

### 2つのデータをあわせてデータフレームを作成する

```{r}
    > age <- c(3,4,5,6,22,25,46,49,70,75)
    > num <- c(15,28,31,15,1,1,1,1,1,1)
    > d <- data.frame(age,num)
    > d
       age num
    1    3  15
    2    4  28
    3    5  31
    4    6  15
    5   22   1
    6   25   1
    7   46   1
    8   49   1
    9   70   1
    10  75   1
    > mean(d$num)
    [1] 9.5
    > median(d$num)
    [1] 1
```

### データをクレンジングしていく

元データ

    > head(a)
        V1 V2 V3 V4     V5       Date weekday
    1 2011 11  1  3      3 2011-11-01  火曜日
    2 2011 10 31  2 136910 2011-10-31  月曜日
    3 2011 11 12  7      3 2011-11-12  土曜日
    4 2010 11 29  2      3 2010-11-29  月曜日
    5 2011 10 22  7  18575 2011-10-22  土曜日
    6 2011 10 26  4 136371 2011-10-26  水曜日

一番簡単なのは、*subset()*のようだ。引数1にデータフレーム、引数2に条件をかけば引数1のサブセットが返される。

    > a2 <- subset(a, V1==2011)
    > a2
         V1 V2 V3 V4     V5       Date weekday
    1  2011 11  1  3      3 2011-11-01  火曜日
    2  2011 10 31  2 136910 2011-10-31  月曜日
    3  2011 11 12  7      3 2011-11-12  土曜日
    5  2011 10 22  7  18575 2011-10-22  土曜日
    (snip)
    56 2011 10 24  2 141333 2011-10-24  月曜日
    57 2011  9 20  3      5 2011-09-20  火曜日
    58 2011  8 19  6      4 2011-08-19  金曜日
    59 2011  9 30  6    369 2011-09-30  金曜日

もちろん2つ以上の条件も可能

    > a2 <- subset(a, V1==2011 & V2==10)
    > a2
         V1 V2 V3 V4     V5       Date weekday
    2  2011 10 31  2 136910 2011-10-31  月曜日
    5  2011 10 22  7  18575 2011-10-22  土曜日
    6  2011 10 26  4 136371 2011-10-26  水曜日
    7  2011 10 23  1  22867 2011-10-23  日曜日
    8  2011 10 21  6 141105 2011-10-21  金曜日
    (snip)
    41 2011 10 10  2 182700 2011-10-10  月曜日
    44 2011 10  6  5  22376 2011-10-06  木曜日
    45 2011 10  9  1 154421 2011-10-09  日曜日
    51 2011 10  4  3   9888 2011-10-04  火曜日
    52 2011 10 27  5 137187 2011-10-27  木曜日
    54 2011 10  8  7  59792 2011-10-08  土曜日
    56 2011 10 24  2 141333 2011-10-24  月曜日

元データがソートされてないので日付順にソートしたい。

sort()関数を使うと指定したカラムのソート結果だけが表示されてしまう。

    > dfa <- data.frame(a2)
    > sort(dfa$Date)
     [1] "2011-10-01" "2011-10-02" "2011-10-03" "2011-10-04" "2011-10-05"
     [6] "2011-10-06" "2011-10-07" "2011-10-08" "2011-10-09" "2011-10-10"
    [11] "2011-10-11" "2011-10-12" "2011-10-13" "2011-10-14" "2011-10-15"
    [16] "2011-10-16" "2011-10-17" "2011-10-18" "2011-10-19" "2011-10-20"
    [21] "2011-10-21" "2011-10-22" "2011-10-23" "2011-10-24" "2011-10-25"
    [26] "2011-10-26" "2011-10-27" "2011-10-28" "2011-10-29" "2011-10-30"
    [31] "2011-10-31"

order()を使うと、カラムのソート順のIDが返されるので、これを利用する。

> order(dfa$Date)
 [1] 13 24 20 28 21 26 15 30 27 25 18 22 23 11 19 14 12  8  7  6  5  2  4 31 16
[26]  3 29 17 10  9  1

データフレームの場所指定をorder()で行うことで全体を取り出す。

    > dfa2 <- dfa[order(dfa$Date),]
    > dfa2
         V1 V2 V3 V4     V5       Date weekday
    19 2011 10  1  7    854 2011-10-01  土曜日
    40 2011 10  2  1   7076 2011-10-02  日曜日
    30 2011 10  3  2  11023 2011-10-03  月曜日
    51 2011 10  4  3   9888 2011-10-04  火曜日
    31 2011 10  5  4  16233 2011-10-05  水曜日
    (snip)
    7  2011 10 23  1  22867 2011-10-23  日曜日
    56 2011 10 24  2 141333 2011-10-24  月曜日
    23 2011 10 25  3 122040 2011-10-25  火曜日
    6  2011 10 26  4 136371 2011-10-26  水曜日
    52 2011 10 27  5 137187 2011-10-27  木曜日
    26 2011 10 28  6 134984 2011-10-28  金曜日
    16 2011 10 29  7  31638 2011-10-29  土曜日
    15 2011 10 30  1  22712 2011-10-30  日曜日
    2  2011 10 31  2 136910 2011-10-31  月曜日

結果、曜日(V4)をX軸に、アクセス数(V5)をY軸にplotする

    > plot(dfa2$V4, dfa2$V5)

営業日に限って1週だけ離れた値があるので、subset()で確認する。第1週の結果がおかしいようだ。

    > subset(dfa2,dfa2$V4==2)
         V1 V2 V3 V4     V5       Date weekday
    30 2011 10  3  2  11023 2011-10-03  月曜日
    41 2011 10 10  2 182700 2011-10-10  月曜日
    18 2011 10 17  2 143092 2011-10-17  月曜日
    56 2011 10 24  2 141333 2011-10-24  月曜日
    2  2011 10 31  2 136910 2011-10-31  月曜日
    > subset(dfa2,dfa2$V4==3)
         V1 V2 V3 V4     V5       Date weekday
    51 2011 10  4  3   9888 2011-10-04  火曜日
    27 2011 10 11  3 169988 2011-10-11  火曜日
    14 2011 10 18  3 146177 2011-10-18  火曜日
    23 2011 10 25  3 122040 2011-10-25  火曜日
    > subset(dfa2,dfa2$V4==4)
         V1 V2 V3 V4     V5       Date weekday
    31 2011 10  5  4  16233 2011-10-05  水曜日
    32 2011 10 12  4 171406 2011-10-12  水曜日
    12 2011 10 19  4 126384 2011-10-19  水曜日
    6  2011 10 26  4 136371 2011-10-26  水曜日
    > subset(dfa2,dfa2$V4==5)
         V1 V2 V3 V4     V5       Date weekday
    44 2011 10  6  5  22376 2011-10-06  木曜日
    37 2011 10 13  5 171775 2011-10-13  木曜日
    9  2011 10 20  5 170227 2011-10-20  木曜日
    52 2011 10 27  5 137187 2011-10-27  木曜日
    > subset(dfa2,dfa2$V4==6)
         V1 V2 V3 V4     V5       Date weekday
    22 2011 10  7  6  58919 2011-10-07  金曜日
    17 2011 10 14  6 131617 2011-10-14  金曜日
    8  2011 10 21  6 141105 2011-10-21  金曜日
    26 2011 10 28  6 134984 2011-10-28  金曜日
    > subset(dfa2,dfa2$V4==7)
         V1 V2 V3 V4    V5       Date weekday
    19 2011 10  1  7   854 2011-10-01  土曜日
    54 2011 10  8  7 59792 2011-10-08  土曜日
    29 2011 10 15  7 55827 2011-10-15  土曜日
    5  2011 10 22  7 18575 2011-10-22  土曜日
    16 2011 10 29  7 31638 2011-10-29  土曜日
    > subset(dfa2,dfa2$V4==1)
         V1 V2 V3 V4     V5       Date weekday
    40 2011 10  2  1   7076 2011-10-02  日曜日
    45 2011 10  9  1 154421 2011-10-09  日曜日
    21 2011 10 16  1  46297 2011-10-16  日曜日
    7  2011 10 23  1  22867 2011-10-23  日曜日
    15 2011 10 30  1  22712 2011-10-30  日曜日
    >


### aggregate

SQLでいうGROUP BYみたいなの。

    > attach(mtcars)
    > head(mtcars)
                       mpg cyl disp  hp drat    wt  qsec vs am gear carb
    Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
    Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
    Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
    Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
    Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
    Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
    > aggdata <-aggregate(mtcars, by=list(cyl,vs),
    +   FUN=mean, na.rm=TRUE)
    > print(aggdata)
      Group.1 Group.2      mpg cyl   disp       hp     drat       wtdetach(mtcars)     qsec vs
    1       4       0 26.00000   4 120.30  91.0000 4.430000 2.140000 16.70000  0
    2       6       0 20.56667   6 155.00 131.6667 3.806667 2.755000 16.32667  0
    3       8       0 15.10000   8 353.10 209.2143 3.229286 3.999214 16.77214  0
    4       4       1 26.73000   4 103.62  81.8000 4.035000 2.300300 19.38100  1
    5       6       1 19.12500   6 204.55 115.2500 3.420000 3.388750 19.21500  1
             am     gear     carb
    1 1.0000000 5.000000 2.000000
    2 1.0000000 4.333333 4.666667
    3 0.1428571 3.285714 3.500000
    4 0.7000000 4.000000 1.500000
    5 0.0000000 3.500000 2.500000
    > detach(mtcars)

もいっこサンプル。サンプルデータ作成のサンプルにも。

    > x <- data.frame(1:5, rep(2, 5), c("B", "A", "A", "B", "A"))
    > colnames(x) <- c("Apple", "Orange", "Class")
    > x
      Apple Orange Class
    1     1      2     B
    2     2      2     A
    3     3      2     A
    4     4      2     B
    5     5      2     A
    > x.agg <- aggregate(x[ , 1:2], sum, by = list(x[ , 3])
    + )
    > x.agg
      Group.1 Apple Orange
    1       A    10      6
    2       B     5      4
    >

### 参考

(http://d.hatena.ne.jp/tsutatsutatsuta/20110522/1306058995)

## サンプル データフレームの作り方

### 連続する数値を設定する

    > 1:10
     [1]  1  2  3  4  5  6  7  8  9 10
    > x <- data.frame(1:5)
    > x
      X1.5
    1    1
    2    2
    3    3
    4    4
    5    5

seqを使うともっといろいろできる。

> seq(17)           // 1:17とおなじ
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
> seq(1,9,by=2)     // 1から9まで2づつ増加
[1] 1 3 5 7 9
> seq(1,9,by=pi)    // 1から9までpiづつ増加
[1] 1.000000 4.141593 7.283185
> seq(1,6,by=3)     // 1から6まで3づつ増加
[1] 1 4
> seq(1.575, 5.125,by=0.05) // 1.575から5.125まで0.05づつ増加
 [1] 1.575 1.625 1.675 1.725 1.775 1.825 1.875 1.925 1.975 2.025 2.075 2.125 2.175
[14] 2.225 2.275 2.325 2.375 2.425 2.475 2.525 2.575 2.625 2.675 2.725 2.775 2.825
[27] 2.875 2.925 2.975 3.025 3.075 3.125 3.175 3.225 3.275 3.325 3.375 3.425 3.475
[40] 3.525 3.575 3.625 3.675 3.725 3.775 3.825 3.875 3.925 3.975 4.025 4.075 4.125
[53] 4.175 4.225 4.275 4.325 4.375 4.425 4.475 4.525 4.575 4.625 4.675 4.725 4.775
[66] 4.825 4.875 4.925 4.975 5.025 5.075 5.125

### 同じ数値を設定する

    > rep(2,5)
    [1] 2 2 2 2 2
    > x <- data.frame(rep(2,5))
    > x
      rep.2..5.
    1         2
    2         2
    3         2
    4         2
    5         2
    > rep(1:3,5)    // 1から3を5times繰り返す
     [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
    > rep(1:3,each=2) // 1から3をそれぞれ2回繰り返す
    [1] 1 1 2 2 3 3
    > rep(1:3,2)    // 省略するとtimesになる
    [1] 1 2 3 1 2 3
    > rep(1:4,c(2,2,2,2)) // ベクトルを渡すと各要素がベクトル回繰り返される
    [1] 1 1 2 2 3 3 4 4
    > rep(1:4,c(2,1,2,1))
    [1] 1 1 2 3 3 4
    > rep(1:3,each=2,len=4) // 繰り返しに長さ指定を行う
    [1] 1 1 2 2
    > rep(1:3,each=2,len=4)
    [1] 1 1 2 2
    > rep(1:3,each=2,len=5)
    [1] 1 1 2 2 3
    > rep(1:3,each=2,len=10)
     [1] 1 1 2 2 3 3 1 1 2 2
    > rep(1:3,each=2,times=3)
     [1] 1 1 2 2 3 3 1 1 2 2 3 3 1 1 2 2 3 3

### リストの中からランダムに設定する

    > sample(c(1,2,3),2)
    [1] 1 3
    > sample(c(1,2,3),2)
    [1] 2 1
    > sample(c(1,2,3),2)
    [1] 2 3
    > sample(c(1,2,3),2)
    [1] 2 3
    > LETTERS
     [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
    [21] "U" "V" "W" "X" "Y" "Z"
    > sample(LETTERS,5)
    [1] "S" "O" "G" "L" "P"
    > x<- data.frame(sample(LETTERS,5))
    > x
      sample.LETTERS..5.
    1                  R
    2                  A
    3                  M
    4                  O
    5                  P

### 組み合わせてデータフレームを作る

    > x <- data.frame(1:5, rep(2, 5), c("B", "A", "A", "B", "A"))
    > colnames(x) <- c("Apple", "Orange", "Class")  // カラムに名前をつける
    > x
      Apple Orange Class
    1     1      2     B
    2     2      2     A
    3     3      2     A
    4     4      2     B
    5     5      2     A

### サンプルデータがあるときのデータフレームの作り方

行ベクトルで作る場合はrbindを使えば良い。

    > x <- rbind(c(0,    0.57, 0.57, 0.57, 0.57),
                 c(0.46, 0,    0,    0,    0   ),
                 c(0,    0.77, 0,    0,    0   ),
                 c(0,    0,    0.82, 0,    0   ),
                 c(0,    0,    0,    0.91, 0.65)  )
    > x
         [,1] [,2] [,3] [,4] [,5]
    [1,] 0.00 0.57 0.57 0.57 0.57
    [2,] 0.46 0.00 0.00 0.00 0.00
    [3,] 0.00 0.77 0.00 0.00 0.00
    [4,] 0.00 0.00 0.82 0.00 0.00
    [5,] 0.00 0.00 0.00 0.91 0.65

代わりに cbind 関数を使うと、列ベクトルとして横に並べられる

    >  x<-cbind(c(0,0.57,0.57,0.57,0.57), c(0.46,0,0,0,0),    c(0,0.77,0,0,0),
                c(0,0,0.82,0,0),          c(0,0,0,0.91,0.65)                 )
    > x
         [,1] [,2] [,3] [,4] [,5]
    [1,] 0.00 0.46 0.00 0.00 0.00
    [2,] 0.57 0.00 0.77 0.00 0.00
    [3,] 0.57 0.00 0.00 0.82 0.00
    [4,] 0.57 0.00 0.00 0.00 0.91
    [5,] 0.57 0.00 0.00 0.00 0.65

### 参考
(http://cse.naro.affrc.go.jp/takezawa/r-tips/r/12.html)

## 配列

配列は添字でアクセスできるデータ型のことを表す。

    > v = c(1:12)           // 1-12の連続する数値のベクトルを作成
    > v
     [1]  1  2  3  4  5  6  7  8  9 10 11 12

    > a <- array(v,c(3,4))       // 3x4の配列に変換
    > a
         [,1] [,2] [,3] [,4]
    [1,]    1    4    7   10
    [2,]    2    5    8   11
    [3,]    3    6    9   12

配列から次元属性を取得

    > dim(a)
    [1] 3 4

添字でアクセスできる。添字の指定は[x,y,z,...]となるが、[x,]でx次元のデータすべて、[,y]でy次元のデータすべてというアクセスが可能。

1次元のアクセスではデータはその順番で取り出せる。

    > a[1]
    [1] 1
    > a[2]
    [1] 2
    > a[4]
    [1] 4

3x4行列(上記aの表記参照)の横でアクセス

    > a[1,]
    [1]  1  4  7 10
    > a[2,]
    [1]  2  5  8 11

3x4行列(上記aの表記参照)の縦でアクセス

    > a[,1]
    [1] 1 2 3
    > a[,2]
    [1] 4 5 6

3x4を4x3にするにはapermをつかう

    > y <- aperm(a, perm=c(2,1))    // AxBの1番目と２番目を入れ替える
    > y
         [,1] [,2] [,3]
    [1,]    1    2    3
    [2,]    4    5    6
    [3,]    7    8    9
    [4,]   10   11   12

applyの第２引数は次元属性の順番である。

    > apply(a,1,sum)    // 結果が3個であることからも分かる通り3x4の1次元目でsumが適用される
    [1] 22 26 30
    > apply(a,2,sum)    // 結果が4個であることからも分かる通り3x4の2次元目でsumが適用される
    [1]  6 15 24 33

## 集計

###参考
(http://d.hatena.ne.jp/a_bicky/20110529/1306667230)
vim: set ft=markdown
